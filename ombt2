#!/usr/bin/env python
#
#    Copyright (C) 2017 Kenneth A. Giusti
#
#    Licensed to the Apache Software Foundation (ASF) under one
#    or more contributor license agreements.  See the NOTICE file
#    distributed with this work for additional information
#    regarding copyright ownership.
#
#    Licensed under the Apache License, Version 2.0 (the "License"); you may
#    not use this file except in compliance with the License. You may obtain
#    a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#    Unless required by applicable law or agreed to in writing, software
#    distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
#    WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
#    License for the specific language governing permissions and limitations
#    under the License.
#

import abc
import argparse
import eventlet
import logging
import math
import os
import socket
import sys
import threading
import time
import uuid
from subprocess import Popen, STDOUT
from time import time as now

from oslo_config import cfg
import oslo_messaging as om


# flags for running in the background
_DAEMON = False
_PARENT_FD = -1

# the types of oslo.messaging clients
RPC_CLIENT = 'RPCClient'
RPC_SERVER = 'RPCServer'
LISTENER = 'Listener'
NOTIFIER = 'Notifier'
MESSAGING_CLIENT_TYPES = [RPC_CLIENT, RPC_SERVER, LISTENER, NOTIFIER]

# addressing for control messages
CONTROL_EXCHANGE = 'ombt-control'
CONTROLLER_TOPIC = 'controller-%s'
CLIENT_TOPIC = "client-%s-%s"    # client-$type-$topic

# addressing for RPC tests
RPC_EXCHANGE = 'ombt-rpc-test'
RPC_TOPIC = "rpc-%s"

# addressing for Notification tests
NOTIFY_EXCHANGE = 'ombt-notify-test'
NOTIFY_TOPIC = "notify-%s"

DEFAULT_LEN = 1024
VERSION = (1, 3, 0)


class Stats(object):
    """Manage a single statistic"""
    def __init__(self):
        self.min = None
        self.max = None
        self.total = 0
        self.count = 0
        self.sum_of_squares = 0
        # distribution of values grouped by powers of 10
        self.distribution = dict()

    def update(self, value):
        self.total += value
        self.count += 1
        self.sum_of_squares += value**2
        self.min = min(self.min, value) if self.min else value
        self.max = max(self.max, value) if self.max else value
        log = int(math.log10(value)) if value else 0
        base = 10**log
        index = int(value/base)  # 0..9
        if log not in self.distribution:
            self.distribution[log] = [0 for i in range(10)]
        self.distribution[log][index] += 1

    def reset(self):
        self.__init__()

    def average(self):
        return (self.total / float(self.count)) if self.count else 0

    def std_deviation(self):
        return math.sqrt((self.sum_of_squares / float(self.count))
                         - (self.average() ** 2)) if self.count else -1

    def merge(self, stats):
        if stats.min is not None and self.min is not None:
            self.min = min(self.min, stats.min)
        else:
            self.min = self.min or stats.min
        if stats.max is not None and self.max is not None:
            self.max = max(self.max, stats.max)
        else:
            self.max = self.max or stats.max

        self.total += stats.total
        self.count += stats.count
        self.sum_of_squares += stats.sum_of_squares
        for k in stats.distribution.keys():
            if k in self.distribution:
                self.distribution[k] = [z for z in map(lambda a, b: a + b,
                                                       stats.distribution[k],
                                                       self.distribution[k])]
            else:
                self.distribution[k] = stats.distribution[k]

    def __str__(self):
        return "min=%i, max=%i, avg=%f, std-dev=%f" % (self.min, self.max,
                                                       self.average(),
                                                       self.std_deviation())

    def print_distribution(self):
        keys = list(self.distribution.keys())
        keys.sort()
        for order in keys:
            row = self.distribution[order]
            index = 0
            while index < len(row):
                if row[index]:
                    print("[%d..<%d):  %d" %
                          ((10 ** int(order)) * index,
                           (10 ** int(order)) * (index + 1),
                           row[index]))
                index += 1


class _Base(object):
    """Common base for all ombt2 processes.  Establishes a connection to the
    control message bus and a subscription for control messages
    """
    def __init__(self, cfg, ctl_url, topic, kind=None):
        super(_Base, self).__init__()
        self._finished = threading.Event()

        if kind is None:
            ctl_topic = CONTROLLER_TOPIC % topic
            self.kind = "Controller"
        else:
            ctl_topic = CLIENT_TOPIC % (kind, topic)
            self.kind = kind

        self.name = 'ombt-%s-%s-%s-%s-%s' % (topic,
                                             kind,
                                             socket.gethostname(),
                                             os.getpid(),
                                             uuid.uuid4().hex)
        self.ctl_url = ctl_url
        self.ctl_tport = om.get_rpc_transport(cfg.CONF,
                                              url=ctl_url)
        # My address and subscription for receiving control commands/responses
        self.ctl_target = om.Target(exchange=CONTROL_EXCHANGE,
                                    topic=ctl_topic,
                                    server=self.name)
        self._ctl_server = om.get_rpc_server(self.ctl_tport,
                                             target=self.ctl_target,
                                             endpoints=[self],
                                             executor="threading")
        self._ctl_server.start()

    def start(self):
        # blocks until connection to the control bus is active
        ready = False
        attempts = 0
        logging.debug("%s connecting to the control message bus...", self.name)
        # call my "self_ready" method until it returns successfully.
        # this indicates the connection to the control bus is active.
        client = om.RPCClient(self.ctl_tport,
                              target=self.ctl_target,
                              timeout=10)
        while not ready and attempts < 25:
            try:
                ready = client.call({}, 'self_ready')
            except om.MessagingTimeout:
                attempts += 1
        if not ready:
            raise Exception("Unable to contact message bus")
        logging.debug("%s is listening", self.name)

    def wait(self, timeout=None):
        # blocks until client completes shutdown
        return self._finished.wait(timeout)

    def _do_shutdown(self):
        self._ctl_server.stop()
        self._ctl_server.wait()
        self._finished.set()
        logging.debug("%s has shut down", self.name)

    #
    # RPC calls:
    #

    def shutdown(self, ctxt):
        # cannot synchronously shutdown server since this call is dispatched by
        # the server...
        threading.Thread(target=self._do_shutdown).start()

    def self_ready(self, ctxt):
        # simple ping to determine when message bus is connected
        return True


class _Client(_Base):
    """Common base for non-controller clients.  Defines RPC calls that are
    invoked by the Controller
    """
    def __init__(self, cfg, ctl_url, topic, kind):
        # listen on 'client-$topic' for controller commands:
        super(_Client, self).__init__(cfg, ctl_url, topic, kind)
        self.topic = CLIENT_TOPIC % (kind, topic)

    #
    # RPC Calls
    #

    def client_ping(self, ctxt, reply_addr):
        # invoked by controller via rpc-cast to roll-call available clients
        logging.debug("Client ping received (%s)", self.name)
        target = om.Target(**reply_addr)
        ctrl = om.RPCClient(self.ctl_tport, target=target, timeout=120)
        try:
            ctrl.cast({}, "client_pong", kind=self.kind, name=self.name)
        except Exception as exc:
            logging.error("client pong call failed: %s", str(exc))
            raise
        else:
            logging.debug("Client pong sent (%s) (%s)", self.name, target)


class _TestClient(_Client):
    """Base class for Notifier and RPC clients
    """
    def __init__(self, cfg, ctl_url, topic, kind):
        super(_TestClient, self).__init__(cfg, ctl_url, topic, kind)

    #
    # RPC Calls
    #

    @abc.abstractmethod
    def run_test(self, ctxt, test, kwargs, reply_addr):
        """Called by the controller to have the client run test 'test' with
        arguments kwargs, send results to controller at reply_addr.  Note: this
        is an RPC method that is invoked by the test controller via 'cast' -
        not 'call' (controller must not block for results)
        """


class _TestServer(_Client):
    """Base class for Listener and RPC servers
    """
    def __init__(self, cfg, ctl_url, topic, kind):
        super(_TestServer, self).__init__(cfg, ctl_url, topic, kind)

        # statistics:
        self._latency = Stats()
        self._start_time = None
        self._stop_time = None

    #
    # Controller RPC Calls
    #

    def get_server_results(self, ctxt, reply_addr):
        """Called by the controller after the clients complete the test to
        gather server side test data.
        """
        results = {'latency': self._latency.__dict__,
                   'start_time': self._start_time,
                   'stop_time': self._stop_time}
        self._latency = Stats()
        self._start_time = None
        self._stop_time = None

        controller = om.RPCClient(self.ctl_tport,
                                  om.Target(**reply_addr),
                                  timeout=120)
        try:
            controller.call({}, 'client_result', kind=self.kind,
                            results=results)
        except Exception as exc:
            logging.error("server result call failed: %s", str(exc))
        else:
            logging.debug("Server %s test results sent", self.name)


class RPCTestClient(_TestClient):
    """Runs the RPC tests against the RPCTestServer
    """
    def __init__(self, cfg, ctl_url, test_url, topic):
        super(RPCTestClient, self).__init__(cfg, ctl_url, topic, RPC_CLIENT)
        # for calling the test RPC server(s):
        target = om.Target(exchange=RPC_EXCHANGE,
                           topic=RPC_TOPIC % topic)
        tport = om.get_rpc_transport(cfg.CONF, url=test_url)
        self._rpc_client = om.RPCClient(tport,
                                        target=target,
                                        timeout=30)
    #
    # RPC Calls:
    #

    def run_test(self, ctxt, test, kwargs, reply_addr):
        func = None
        verbose = kwargs.get("verbose", False)
        pause = kwargs.get("pause", 0)
        data = kwargs.get("data", "")
        count = kwargs.get("count", 0)

        if test == "test_call":
            func = lambda ts: self._rpc_client.call({}, 'echo', data=data,
                                                    timestamp=ts)
        elif test == "test_cast":
            func = lambda ts: self._rpc_client.cast({}, 'noop', data=data,
                                                    timestamp=ts)
        else:
            logging.warning("Client %s ignoring unknown test %s",
                            self.name, test)
            return

        controller = om.RPCClient(self.ctl_tport,
                                  om.Target(**reply_addr),
                                  timeout=120)
        logging.debug("Client %s starting test %s ...", self.name, test)

        try:
            latency = Stats()
            pause = float(pause)/1000.0
            stop = False
            t_start = now()
            while not stop:
                t = now()
                func(t)
                latency.update((now() - t) * 1000)
                if (pause): time.sleep(pause)
                if (verbose and count and
                        (latency.count % (max(10, count)/10) == 0)):
                    logging.info("Call %i of %i completed", latency, count)
                if count and latency.count >= count:
                    stop = True
            t_end = now()
            results = {'latency': latency.__dict__,
                       'start_time': t_start,
                       'stop_time': t_end}
        except Exception as ex:
            logging.error("Test failure: %s", str(ex))
            results = {'failure': str(ex)}

        logging.debug("Client %s test %s finished, sending results...",
                      self.name, test)
        try:
            controller.call({}, 'client_result', kind=self.kind,
                            results=results)
        except Exception as exc:
            logging.error("client result call failed: %s", str(exc))
        else:
            logging.debug("Client %s test %s results sent", self.name, test)


class RPCTestServer(_TestServer):
    """Response to RPC requests from RPCTestClient
    """
    def __init__(self, cfg, ctl_url, test_url, topic, executor):
        super(RPCTestServer, self).__init__(cfg, ctl_url, topic, RPC_SERVER)
        target = om.Target(exchange=RPC_EXCHANGE,
                           topic=RPC_TOPIC % topic,
                           server=self.name)
        tport = om.get_rpc_transport(cfg.CONF, url=test_url)
        self._rpc_server = om.get_rpc_server(tport,
                                             target,
                                             [self],
                                             executor=executor)
        self._rpc_server.start()

    def _update_stats(self, timestamp):
        # given timestamp from arriving message
        ts = now()
        self._start_time = self._start_time or ts
        self._stop_time = ts
        if timestamp > ts:
            logging.warning("Possible clock drift detected:"
                            "send time (%f) after arrival time (%f)",
                            timestamp, ts)
            return
        self._latency.update((ts - timestamp) * 1000)

    #
    # Controller RPC Calls:
    #

    def shutdown(self, ctxt):
        self._rpc_server.stop()
        self._rpc_server.wait()
        super(RPCTestServer, self).shutdown(ctxt)

    #
    # Test RPC Calls:
    #

    def noop(self, ctxt, data, timestamp):
        # for cast testing - called by RPCTestClient, no return value
        self._update_stats(timestamp)
        logging.debug("RPCServer.noop(timestamp=%s)", timestamp)

    def echo(self, ctxt, data, timestamp):
        # for call testing - called by RPCTestClient
        self._update_stats(timestamp)
        logging.debug("RPCServer.echo(timestamp=%s)", timestamp)
        return data


class TestNotifier(_TestClient):
    """Client for issuing Notification calls to the TestListener
    """
    def __init__(self, cfg, ctl_url, test_url, topic):
        super(TestNotifier, self).__init__(cfg,
                                           ctl_url,
                                           topic,
                                           NOTIFIER)
        # for notifying the test listener:
        om.set_transport_defaults(control_exchange=NOTIFY_EXCHANGE)
        tport = om.get_notification_transport(cfg.CONF, url=test_url)
        topic = NOTIFY_TOPIC % topic
        self._notifier = om.notify.notifier.Notifier(tport,
                                                     self.name,
                                                     driver='messaging',
                                                     topics=[topic])
    #
    # RPC Calls:
    #

    def run_test(self, ctxt, test, kwargs, reply_addr):
        if test != 'test_notify':
            # ignore other tests, like rpc-call, etc
            return
        verbose = kwargs.get("verbose", False)
        pause = kwargs.get("pause", 0)
        data = kwargs.get("data", "")
        count = kwargs.get("count", 0)
        severity = kwargs.get("severity", "debug")

        controller = om.RPCClient(self.ctl_tport,
                                  om.Target(**reply_addr),
                                  timeout=30)
        logging.debug("Client %s starting test %s ...", self.name, test)

        try:
            latency = Stats()
            pause = float(pause)/1000.0
            func = getattr(self._notifier, severity)
            payload = {'payload': data}
            stop = False
            t_start = now()
            while not stop:
                t = now()
                payload['timestamp'] = t
                func({}, "notification-test", payload)
                latency.update((now() - t) * 1000)
                if (pause): time.sleep(pause)
                if (verbose and count and
                        (latency.count % (max(10, count)/10) == 0)):
                    logging.info("Call %i of %i completed",
                                 latency.count, count)
                if count and latency.count >= count:
                    stop = True
            t_end = now()
            results = {'latency': latency.__dict__,
                       'start_time': t_start,
                       'stop_time': t_end}
        except Exception as ex:
            logging.error("Test failure: %s", str(ex))
            results = {'failure': str(ex)}

        logging.debug("Client %s test %s finished, sending results...",
                      self.name, test)
        try:
            controller.call({}, 'client_result', kind=self.kind,
                            results=results)
        except Exception as exc:
            logging.error("client result call failed: %s", str(exc))
        else:
            logging.debug("Client %s test %s results sent", self.name, test)


class TestListener(_TestServer):
    def __init__(self, cfg, ctl_url, test_url, topic, executor):
        super(TestListener, self).__init__(cfg,
                                           ctl_url,
                                           topic,
                                           LISTENER)
        target = om.Target(exchange=NOTIFY_EXCHANGE,
                           topic=NOTIFY_TOPIC % topic,
                           server=self.name)
        om.set_transport_defaults(control_exchange=NOTIFY_EXCHANGE)
        tport = om.get_notification_transport(cfg.CONF, url=test_url)
        self._listener = om.get_notification_listener(tport,
                                                      [target],
                                                      [self],
                                                      executor=executor)
        self._listener.start()

    #
    # Controller RPC Calls:
    #

    def shutdown(self, ctxt):
        self._listener.stop()
        self._listener.wait()
        super(TestListener, self).shutdown(ctxt)

    #
    # Notifications:
    #

    def _report(self, severity, ctx, publisher, event_type, payload, metadata):
        arrived = now()
        self._start_time = self._start_time or arrived
        self._stop_time = arrived
        logging.debug("%s Notification %s:%s:%s:%s:%s", self.name, severity,
                      publisher, event_type, payload, metadata)
        try:
            sent = payload['timestamp']
        except KeyError:
            logging.warning("notification does not contain a timestamp")
        else:
            if sent > arrived:
                logging.warning("Possible clock drift detected:"
                                "send time (%f) after arrival time (%f)",
                                sent, arrived)
                return

            self._latency.update((arrived - sent) * 1000)

    def debug(self, ctx, publisher, event_type, payload, metadata):
        self._report("debug", ctx, publisher, event_type, payload, metadata)

    def audit(self, ctx, publisher, event_type, payload, metadata):
        self._report("audit", ctx, publisher, event_type, payload, metadata)

    def critical(self, ctx, publisher, event_type, payload, metadata):
        self._report("critical", ctx, publisher, event_type, payload, metadata)

    def error(self, ctx, publisher, event_type, payload, metadata):
        self._report("error", ctx, publisher, event_type, payload, metadata)

    def info(self, ctx, publisher, event_type, payload, metadata):
        self._report("info", ctx, publisher, event_type, payload, metadata)

    def warn(self, ctx, publisher, event_type, payload, metadata):
        self._report("warn", ctx, publisher, event_type, payload, metadata)


class Controller(_Base):
    """The test controller
    """
    def __init__(self, cfg, ctl_url, topic, timeout):
        # each controller has a unique topic not to be confused
        # with future or past controller instances
        self.topic = topic
        self._timeout = timeout
        super(Controller, self).__init__(cfg, ctl_url, topic)
        self._minions = dict()  # count of clients per type
        self._total_minions = 0
        self._latency = dict()
        self._throughput = dict()
        self._clients = dict()  # rpc client for each type
        self._done = threading.Event()

    def start(self):
        super(Controller, self).start()
        logging.debug("Polling for clients...")
        reply = {'exchange': self.ctl_target.exchange,
                 'topic': self.ctl_target.topic,
                 'server': self.ctl_target.server}
        for kind in MESSAGING_CLIENT_TYPES:
            target = om.Target(exchange=CONTROL_EXCHANGE,
                               topic=CLIENT_TOPIC % (kind, self.topic),
                               fanout=True)
            self._clients[kind] = om.RPCClient(self.ctl_tport, target=target)
            self._clients[kind].cast({}, 'client_ping', reply_addr=reply)

        # wait until no more clients reply to the ping
        # for a few seconds
        minions = 0
        delay = 5
        while delay > 0:
            time.sleep(1.0)
            if minions != self._total_minions:
                minions = self._total_minions
                delay = 5  # reset
            else:
                delay -= 1

    def shutdown(self):
        """Shutdown this Controller
        """
        super(Controller, self).shutdown({})
        self.wait()

    def shutdown_clients(self):
        """Shutdown all clients listening to $topic
        """
        for kind in MESSAGING_CLIENT_TYPES:
            self._clients[kind].cast({}, 'shutdown')
        time.sleep(1.0)

    def run_call_test(self, count, data, verbose, pause):
        kwargs = {'verbose': verbose,
                  'pause': pause,
                  'data': data,
                  'count': count}
        self._run_test(RPC_CLIENT, 'test_call', kwargs)
        self._query_servers(RPC_SERVER)
        # only report the RPC_CLIENT stats since they are round-trip
        self._print_stats("RPC call",
                          self._latency[RPC_CLIENT],
                          self._throughput[RPC_CLIENT])

    def run_cast_test(self, count, data, verbose, pause):
        kwargs = {'verbose': verbose,
                  'pause': pause,
                  'data': data,
                  'count': count}
        self._run_test(RPC_CLIENT, 'test_cast', kwargs)
        self._query_servers(RPC_SERVER)
        # latency is measured at the server (no return trip)
        self._print_stats("RPC cast",
                          self._latency[RPC_SERVER],
                          self._throughput[RPC_CLIENT])

    def run_notification_test(self, count, data, severity, verbose, pause):
        kwargs = {'verbose': verbose,
                  'pause': pause,
                  'data': data,
                  'count': count,
                  'severity': severity}
        self._run_test(NOTIFIER, 'test_notify', kwargs)
        self._query_servers(LISTENER)
        self._print_stats("Notification",
                          self._latency[LISTENER],
                          self._throughput[NOTIFIER])

    def _run_test(self, kind, test, kwargs):
        """Tell the messaging clients to run a test.  When the client completes
        it will call the 'client_result' method below.
        """
        if self._minions.get(kind, 0) == 0:
            raise Exception("No %s clients visible" % kind)

        self._done.clear()
        reply = {'exchange': self.ctl_target.exchange,
                 'topic': self.ctl_target.topic,
                 'server': self.ctl_target.server}

        # tell 'kind' clients to run the test
        self._clients[kind].cast({}, 'run_test',
                                 test=test,
                                 kwargs=kwargs,
                                 reply_addr=reply)
        if not self._done.wait(self._timeout):
            raise Exception("%s test timed out!" % test)

    def _query_servers(self, kind):
        """Ask the servers for any data gathered during the test. The servers
        will respond by calling the 'server_result' method below.
        """
        if self._minions.get(kind, 0) == 0:
            raise Exception("No %s servers visible" % kind)

        self._done.clear()
        reply = {'exchange': self.ctl_target.exchange,
                 'topic': self.ctl_target.topic,
                 'server': self.ctl_target.server}
        # tell all clients to run the test
        # tell 'kind' clients to run the test
        self._clients[kind].cast({}, 'get_server_results',
                                 reply_addr=reply)
        if not self._done.wait(self._timeout):
            raise Exception("Timed out waiting for server query")

    def _print_stats(self, name, latency, throughput):
        # total, count, std_dev, min, max, avg, dist
        print("\n")
        print("%s test results:" % name)
        print("  Latency %s samples (msecs): Average %s StdDev %s"
              " Min %s Max %s"
              % (latency.count,
                 latency.average(), latency.std_deviation(),
                 latency.min, latency.max))
        print("  Distribution: ")
        latency.print_distribution()
        print("\n")
        print("  Throughput %s samples (ops/sec): Average %s StdDev %s"
              " Min %s Max %s"
              % (throughput.count,
                 throughput.average(), throughput.std_deviation(),
                 throughput.min, throughput.max))
        print("  Distribution: ")
        throughput.print_distribution()

    #
    # RPC calls:
    #
    def client_pong(self, ctxt, kind, name):
        # A client 'name' is checking in
        if kind not in self._minions:
            self._minions[kind] = 0
        self._minions[kind] += 1
        self._total_minions += 1
        logging.debug("New %s detected (%s) - %d total clients found",
                      kind, name, self._total_minions)

    def client_result(self, ctxt, kind, results):
        # A client is reporting a test result in response to the above
        # _run_test method
        try:
            latency = results['latency']
            start_time = results['start_time']
            stop_time = results['stop_time']
        except KeyError:
            raise Exception("Error: Client reports test failure: %s",
                            results.get('failure', 'cause unknown'))
        if start_time > stop_time:
            raise Exception("Error possible clock drift detected")
        if not latency.get('count'):
            raise Exception("Error: client returned sample count of zero")

        l = Stats()
        l.__dict__.update(latency)
        if kind not in self._latency:
            self._latency[kind] = Stats()
        self._latency[kind].merge(l)
        if kind not in self._throughput:
            self._throughput[kind] = Stats()
        ival = stop_time - start_time
        thruput = 0 if ival == 0 else float(l.count) / ival
        self._throughput[kind].update(thruput)
        logging.debug("  result %i of %i"
                      " - Throughput: %i, Latency:%s",
                      self._latency[kind].count,
                      self._minions[kind], thruput, l)
        self._minions[kind] -= 1
        if self._minions[kind] == 0:
            self._done.set()


def _parse_args(args, values):
    for i in range(len(args)):
        arg = args[i].lower()
        try:
            key, value = arg.split('=')
        except ValueError:
            print("Error - argument format is key=value")
            print(" - %s is not valid" % str(arg))
            raise SyntaxError("bad argument: %s" % arg)
        if key not in values:
            print("Error - unrecognized argument %s" % key)
            print(" - arguments %s" % [x for x in iter(values)])
            raise SyntaxError("unknown argument: %s" % key)
        values[key] = int(value) if isinstance(values[key], int) else value
    return values


def _do_shutdown(cfg, args):
    controller = Controller(cfg, args.control, args.topic, args.timeout)
    controller.start()
    controller.shutdown_clients()
    controller.shutdown()


def _rpc_call_test(cfg, args):
    controller = Controller(cfg, args.control, args.topic, args.timeout)
    args = _parse_args(args.args, {'length': DEFAULT_LEN, 'calls': 1,
                                   'pause': 0, 'verbose': False})
    controller.start()
    controller.run_call_test(args['calls'], 'X' * args['length'],
                             args['verbose'], args['pause'])
    controller.shutdown()


def _rpc_cast_test(cfg, args):
    controller = Controller(cfg, args.control, args.topic, args.timeout)
    args = _parse_args(args.args, {'length': DEFAULT_LEN, 'calls': 1,
                                   'pause': 0, 'verbose': False})
    controller.start()
    controller.run_cast_test(args['calls'], 'X' * args['length'],
                             args['verbose'], args['pause'])
    controller.shutdown()


def _notify_test(cfg, args):
    controller = Controller(cfg, args.control, args.topic, args.timeout)
    args = _parse_args(args.args, {'length': DEFAULT_LEN, 'calls': 1,
                                   'severity': 'debug',
                                   'verbose': None,
                                   'pause': 0})
    controller.start()
    controller.run_notification_test(args['calls'], 'X' * args['length'],
                                     args['severity'], args['verbose'],
                                     args['pause'])
    controller.shutdown()


def controller(cfg, args):
    TESTS = {'rpc-call': _rpc_call_test,
             'rpc-cast': _rpc_cast_test,
             'shutdown': _do_shutdown,
             'notify': _notify_test}
    func = TESTS.get(args.test.lower())
    if func is None:
        print("Error - unrecognized command %s" % args.test)
        print("commands: %s" % [x for x in iter(TESTS)])
        return -1
    return func(cfg, args)


def rpc_standalone(cfg, args):
    server = RPCTestServer(cfg,
                           args.control,
                           args.url,
                           args.topic,
                           args.executor)
    server.start()
    client = RPCTestClient(cfg, args.control, args.url, args.topic)
    client.start()

    controller = Controller(cfg, args.control, args.topic, args.timeout)
    controller.start()

    if args.do_cast:
        controller.run_cast_test(args.calls,
                                 'X' * args.length,
                                 args.debug, 0)
    else:
        controller.run_call_test(args.calls,
                                 'X' * args.length,
                                 args.debug, 0)
    controller.shutdown_clients()
    controller.shutdown()


def notify_standalone(cfg, args):
    server = TestListener(cfg,
                          args.control,
                          args.url,
                          args.topic,
                          args.executor)
    server.start()
    client = TestNotifier(cfg, args.control, args.url, args.topic)
    client.start()

    controller = Controller(cfg, args.control, args.topic, args.timeout)
    controller.start()
    controller.run_notification_test(args.calls,
                                     'X' * args.length,
                                     'debug',  # todo: fix
                                     args.debug, 0)
    controller.shutdown_clients()
    controller.shutdown()


def _run_as_daemon():
    #
    # run the command in a child process
    #
    cmdline = sys.argv[:]
    cmdline.remove("--daemon")
    cmdline.append("-X-daemon")
    if 'python' not in cmdline[0]:
        # hack to run correctly under virtualenv
        cmdline = [sys.executable] + cmdline

    p = os.pipe()
    child = Popen(cmdline, bufsize=0, stderr=STDOUT, stdout=p[1])
    out = ""
    while True:
        b = os.read(p[0], 1000).decode()
        # hack, why doesn't os.read() return when the pipe is closed???
        if not b or b[-1] == '\n':
            break
        out += b
    print("%s" % out)


def rpc_server(cfg, args):
    server = RPCTestServer(cfg, args.control, args.url, args.topic,
                           args.executor)
    server.start()
    if _DAEMON:
        msg = "RPC server %s is ready\n" % server.name
        os.write(_PARENT_FD, msg.encode())
        os.close(_PARENT_FD)
    server.wait()


def rpc_client(cfg, args):
    client = RPCTestClient(cfg, args.control, args.url, args.topic)
    client.start()
    if _DAEMON:
        msg = "RPC client %s is ready\n" % client.name
        os.write(_PARENT_FD, msg.encode())
        os.close(_PARENT_FD)
    client.wait()


def listener(cfg, args):
    listener = TestListener(cfg, args.control, args.url, args.topic,
                            args.executor)
    listener.start()
    if _DAEMON:
        msg = "Listener %s is ready\n" % listener.name
        os.write(_PARENT_FD, msg.encode())
        os.close(_PARENT_FD)
    listener.wait()


def notifier(cfg, args):
    notifier = TestNotifier(cfg, args.control, args.url, args.topic)
    notifier.start()
    if _DAEMON:
        msg = "Notifier %s is ready\n" % notifier.name
        os.write(_PARENT_FD, msg.encode())
        os.close(_PARENT_FD)
    notifier.wait()


def main():
    eventlet.monkey_patch()
    parser = argparse.ArgumentParser(
        description=('Benchmark tool for oslo.messaging (v%d.%d.%d)'
                     % VERSION))

    parser.add_argument("--url",
                        default='rabbit://localhost:5672',
                        help="The address of the messaging service under test")
    parser.add_argument("--control",
                        default=None,
                        help="The address of the messaging service used for"
                        " control of ombt2. Defaults to --url value.")
    parser.add_argument("--oslo-config",
                        help="oslo.messaging configuration file")
    parser.add_argument('--topic', default='test-topic',
                        help='service address to use')
    parser.add_argument('--debug', action='store_true',
                        help='Enable DEBUG logging')
    parser.add_argument("--timeout", type=int, default=None,
                        help='fail test after timeout seconds')
    parser.add_argument("--logfile-prefix", type=str, default=None,
                        help="File for logging. The filename is created from"
                        " appending the process id (pid) to the prefix.")

    subparsers = parser.add_subparsers(dest='mode',
                                       description='operational mode')
    # RPC Standalone
    sp = subparsers.add_parser('rpc',
                               description='standalone RPC test')
    sp.add_argument("--calls", type=int, default=1,
                    help="Number of RPC calls to perform")
    sp.add_argument("--length", type=int, default=DEFAULT_LEN,
                    help='length in bytes of payload string')
    sp.add_argument("--cast", dest='do_cast', action='store_true',
                    help='RPC cast instead of RPC call')
    sp.add_argument("--executor", default="threading",
                    help="type of executor the server will use")

    # Notification Standalone
    sp = subparsers.add_parser('notify',
                               description='standalone notification test')
    sp.add_argument("--calls", type=int, default=1,
                    help="Number of RPC calls to perform")
    sp.add_argument("--length", type=int, default=DEFAULT_LEN,
                    help='length in bytes of payload string')
    sp.add_argument("--executor", default="threading",
                    help="type of executor the server will use")

    # Test controller
    sp = subparsers.add_parser('controller',
                               description='Controller mode')
    sp.add_argument("test", help='the test to run')
    sp.add_argument('args', nargs='*', help='test arguments')

    # RPC Server
    sp = subparsers.add_parser('rpc-server',
                               description='RPC Server mode')
    sp.add_argument("--daemon", action='store_true',
                    help='Run the server in the background')
    sp.add_argument("--executor", default="threading",
                    help="type of executor the server will use")

    # RPC Client
    sp = subparsers.add_parser('rpc-client',
                               description='RPC Client mode')
    sp.add_argument("--daemon", action='store_true',
                    help='Run the client in the background')

    # Listener
    sp = subparsers.add_parser('listener',
                               description='Notification listener mode')
    sp.add_argument("--executor", default="threading",
                    help="type of executor the server will use")
    sp.add_argument("--daemon", action='store_true',
                    help='Run the listener in the background')

    # Notifier
    sp = subparsers.add_parser('notifier',
                               description='Notifier mode')
    sp.add_argument("--daemon", action='store_true',
                    help='Run the notifier in the background')

    args = parser.parse_args()

    logging.basicConfig(level=logging.DEBUG if args.debug else logging.WARN,
                        filename=args.logfile_prefix + str(os.getpid())
                        if args.logfile_prefix else None)

    # run in the background if specified:
    if getattr(args, 'daemon', False):
        return _run_as_daemon()

    if args.oslo_config:
        cfg.CONF(["--config-file", args.oslo_config])

    args.control = args.control or args.url

    {'controller': controller,
     'rpc': rpc_standalone,
     'rpc-server': rpc_server,
     'rpc-client': rpc_client,
     'notify': notify_standalone,
     'listener': listener,
     'notifier': notifier}[args.mode](cfg, args)

    return None


if __name__ == "__main__":

    # determine if this command is running in
    # the background:
    if '-X-daemon' in sys.argv:

        _DAEMON = True

        # the parent process is waiting for this process to print that it is
        # ready on stdout so it can block until the child is done initializing
        # re-direct stdio to devnull to avoid any spurious output from causing
        # the parent to unblock prematurely

        _PARENT_FD = os.dup(sys.stdout.fileno())
        os.dup2(os.open(os.devnull, os.O_RDONLY), sys.stdin.fileno())
        os.dup2(os.open(os.devnull, os.O_WRONLY), sys.stdout.fileno())
        os.dup2(os.open(os.devnull, os.O_WRONLY), sys.stderr.fileno())
        sys.argv.remove('-X-daemon')

    sys.exit(main())
